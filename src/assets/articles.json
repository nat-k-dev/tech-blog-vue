[
	{ 
        "id": 1, 
        "title": "Browser: cookies, storage, cache", 
        "description": "These are important terms to better understand how browser works and how to use resources effectively.", 
        "previewImage": "Browser_cookies_storage_cache.png",
        "previewImageDescription": "browsers tools for storage",
        "content": "<p>&nbsp;&nbsp;&nbsp;&nbsp; These are important terms to better understand how browser works and how to use resources effectively.</p><p><strong>Cookies </strong>— they are small strings, usually webserver sets cookies and then browser sends them in every http-request. Browsers have limits for cookies, they can save no more than around 20 cookies and no more than about 4 KB of strings data. Cookies are useful to identify users by the webserver via http-request, so the webserver can responds with more user-personal data. And cookies are important when a user needs authentication. Cookies have not only a value, but also additional security options for every cookie-string, and developer should think about these security options as well. And cookies could expire.&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>Local Storage </strong>and <strong>Session Storage </strong>— they are strings of data, which browser can store. localStorage is stored even after the tab was closed. sessionStorage is stored only when the tab is open, and when you close webpage the sessionStorage is cleaning. localStorage and sessionStorage cannot expire, they are limited by browser for about 5 MB size, they have several methods to work with them, for example, localStorage.getItem(key), sessionStorage.setItem(key, value), localStorage.removeItem(key), etc..</p><p>&nbsp; &nbsp; &nbsp; &nbsp; You can find list of cookies, Local Storage and Session Storage value in a browser's Developer Tools. For example, Chrome browser keeps them in 'Application' tab:</p><img style='width: calc(100% - 10rem); margin: 1rem 5rem 0.5rem;' src='articleId_1_imageN_1.png' alt='Chrome Developer Tools, Application tab, Local Storage, Session Storage, Cookies' title='Chrome Developer Tools, Application tab, Local Storage, Session Storage, Cookies' loading='lazy' class='center'><figcaption style='width: calc(100% - 10rem); margin: 0 5rem 0.5rem; font-style:italic;'>Chrome Developer Tools, Application tab, Local Storage, Session Storage, Cookies</figcaption><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>Cache</strong> — is a storage for resources in web browsers. It helps to keep some images and other data from websites in order to load these websites more quickly. The browser's developers implement the browsers caching. And there is a possibility to implement some caching for website's developers. In this case a website's developer could use Local Storage to store some resources in the browser.&nbsp;</p>"
    },
	{ 
        "id": 2, 
        "title": "How the browser parses and constructs a web page", 
        "description": "This question is often shown in the list of the interview questions for frontend developers. That's interesting that the answer, actually, is not only to demonstrate the level of one's erudition and outlook. ", 
        "previewImage": "browser-logos.webp",
        "previewImageDescription": "browsers logos",
        "content": "<p>&nbsp;&nbsp;&nbsp; This question is often shown in the list of the interview questions for frontend developers. That's interesting that the answer, actually, is not only to demonstrate the level of one's erudition and outlook. Of course, after reading more about this topic I started to look at all my time in web browser quite differently. But it might also help to improve performance of the websites and understand security. I even decided to make several examinations on my website to check if I took the right approaches. So, it's practical and let's go on.</p><h3 style='text-align: center;line-height: 2rem; margin-top: 1rem;'>Architecture. Modern browsers are multi process applications.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It was discovery about modern browsers architecture that they consist of several processes. Actually, now there is no '1 process for 1 opened browser window' anymore. It was before, in very old times, and this approach caused low performance, instability (in case of freezing of the browser the user often had to choose to shut it down). Now there are many processes for different parts of the browser. They are processes for browser itself, for rendering, for plugins (each plugin is in a separate process), for devices, for video, for audio and some others. If one of the plugins crashes, the browser continues to work. If webpage rendering fails or Javascript during rendering crashes, then only the process of certain web page rendering falls down, and other tabs work and browser works as well.&nbsp;</p><h3 style='text-align: center;line-height: 2rem; margin-top: 1rem;'>Steps in loading web page</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So, which steps are implemented by a browser when I open a web page:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1).User input (<em>processed inside browser process</em>). Handle user input (click link, enter web-adress in link bar, etc), process it (form a google-request with user's input or read direct link, add http/https protocol information) and form a url-request. Pass formed data from browser process to the network process.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2).Navigation (<em>network process</em>):</p><ul>  <li>Firstly, a browser looks up the necessary web page in its <strong>cache</strong>.</li>  <li><strong>DNS</strong>. Secondly, if nothing was found in the cache, browser sends a request with url-name to a <strong>DNS</strong> (Domain Name System) server. DNS responds to the browser's machine with an IP-address of asked url-name.</li>  <li><strong>TCP handshake</strong>. When IP address is known the browser tries to connect a machine with this IP address with a help of three-messages handshake ('Are you ready?' - 'I am ready' - 'Nice, now I am completely ready. Let's both get ready').&nbsp;</li>   <li><strong>TLS handshake</strong>. Then a secure connection is established via several messages between the browser and a machine with the IP address.&nbsp;</li>   <li><strong>URL request</strong>. When secure connection is established then it is time to send a URL request from the browser. And finally to get a response. The network process decides what to do with response. If it is a response with status 200 and with html, css, javascript, images and other resources, then the network process tells to browser process that the data is ready to de downloaded.&nbsp;</li>   <li><strong>Preparing rendering process</strong> (<em>browser process</em>). The browser creates rendering process, which will be responsible for showing all these data to the user.</li>   <li><strong>Complete navigation</strong> (<em>team work of several processes</em>). The browser process clean old previous document, the rendering process gets document (html, css, js, etc.) from network process, the rendering process tells the browser process that everything is ready to be rendered.&nbsp;</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3).Parsing and rendering (<em>renderer process</em>).&nbsp;</p><ul>  <li><strong>DOM</strong> (Document Object Model) tree is created from HTML. It represents html-nodes from html-document in a tree which is understandable for browser.</li>   <li><strong>Computed styles</strong> are created from CSS, it has also a structure of a tree (<strong>CSSOM</strong>). Starting from main nodes the styles cascade each others.</li>   <li><strong>Javascript </strong>scripts are interpreted and executed. They parsed into abstract syntaxes trees which is also understandable for browser as other trees (DOM and CSSOM).</li>   <li><strong>AOM </strong>(Accessibility Object Model) tree is created.&nbsp;</li><li><strong>Layout</strong> tree is created from DOM tree and CSSOM tree. Here appears height, width and position of each node and each object on a web page, with taking the viewport size into consideration.</li>   <li><strong>Layer </strong>tree is created from Layout tree. For example, scroll bar, <em>&lt;video&gt;</em> and <em>&lt;canvas&gt;</em> are located on a different layer than a main document, as well as some html-nodes with CSS properties <em>opacity</em>, 3D <em>transform</em>.</li>  <li><strong>Paint records </strong>are formed from Layer tree and Layout tree. Paint records consist of several information: action (for example, draw rectangle), coordinates, size, styles. The result of this stage is a list of many paint records which describes how to paint the web page.</li>   <li><strong>Tilling. </strong>The document is separated to portions of the screen (tills) of equal size, each portion is a set of paint records, assembles together to paint the individual nodes of web page to the screen.&nbsp;</li>   <li><strong>Raster</strong> of the tills via GPU. It happen in some cases in order to raster images not on CPU but on GPU for better performance.</li>   <li><strong>Drawing</strong>. The rastered bitmaps from GPU are composed in separate parts of web page.&nbsp;</li> </ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4).Display (<em>browser process</em>). The browser process receives the command that it is time to display all the rastered data. It finally composes the frame of the page and shows it to us.</p><h3 style='text-align: center;line-height: 2rem; margin-top: 1rem;'>Advices about performance</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Advice</strong>: some parts in browser work in single thread. It may block user intercations and stop rendering. So the ideas are to remove long term functions and actions from the main thread, to load firstly lightweight resources, and the highweight resource last.</p><ul>   <li>Images and CSS are not blocking resources.&nbsp;</li>   <li>Script tag without async or defer are blocking resources. They block rendering, and pause the parsing of HTML.</li> </ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Advice</strong>: keep the images, scripts, fonts, any other data on the same domain name. It helps to reduce to one the amount of requests from browser to DNS server. Every new domain name, which wasn't previosly cached by the browser, should be deciphered by the request to DNS. And every new url request, especially from mobile phones dependant on the distance from cell site, costs some time.</p><h3 style='text-align: center;line-height: 2rem; margin-top: 1rem;'>Important for web optimizations terms</h3><ul>   <li>TTFB - Time to First Byte</li>   <li>FMP - First Meaningful Paint</li>   <li>FCP - First Contentful Paint</li>   <li>14 Kb rule - this is an amount of a first contenful message. So it is a good practice to include into a first responde a html, css and scripts of 14 Kb size in total, so the browser can start drawing something.&nbsp;</li>   <li>TTI - Time to Interactive. The time between DNS Lookup and before the web page becomes interactive. Time to Interactive is hapenning after the First Contentful Paint. Good practice is to keep TTI less than 50 ms. ANd parsing, compiling and executing Javascript shouldn't block for a long time and web page should respond to user interactions quickly.</li> </ul>" 
    },
	{ 
        "id": 3, 
        "title": "GIMP: Extract images from PSD", 
        "description": "Short instruction with screenshots", 
        "previewImage": "gimp.png",
        "previewImageDescription": "GIMP logo",
        "content": "<ul>   <li>GIMP: go to Edit -&gt; Preferences -&gt; Tool Options. In the section 'Move Tool' tick 'Set layer or path as active' in the bottom section. Now you can move layers.&nbsp;</li> </ul> <img style='width: calc(100% - 10rem); margin: 1rem 5rem 0.5rem;' class='center' src='articleId_3_imageN_1.png' alt='Tool Options -> Move Tool -> Set layer or path as active' title='Tool Options -> Move Tool -> Set layer or path as active' loading='lazy' id='image_natalia_kutina_3529'> <figcaption style='width: calc(100% - 10rem); margin: 0 5rem 0.5rem; font-style:italic;'>Tool Options -&gt; Move Tool -&gt; Set layer or path as active</figcaption><ul>   <li>Click 'Move Tool' button.</li> </ul> <img style='width: calc(100% - 10rem); margin: 1rem 5rem 0.5rem;' class='center' src='articleId_3_imageN_2.png' alt='Move Tool button' title='Move Tool button' loading='lazy' id='image_natalia_kutina_3759'><figcaption style='width: calc(100% - 10rem); margin: 0 5rem 0.5rem; font-style:italic;'>Move Tool button</figcaption><ul>  <li>Select a layer. Press <strong>Ctrl+C</strong> to copy the layer. Press <strong>Shift+Ctrl+V </strong>to create a new file from a clipboard.</li>  <li>Save the new file as png via File -&gt; Export As</li></ul>" 
    },
	{ 
        "id": 4, 
        "title": "OpenSSH for github, host and local machines", 
        "description": "The goal: to push changes of the web application quickly from my local machine to both github and the hosting machine.", 
        "previewImage": "open-ssh.png",
        "previewImageDescription": "OpenSSH logo",
        "content": "<h2 style='text-align: center; line-height: 2rem; margin-top: 1rem;'>What we have: </h2> <ul><li>a web application, located on remote server. This server is provided by a third-part hosting provider. The web application is running from this server and becomes available through www.</li> <li>the web application, located on my local machine (Ubuntu). To change our web application source code.</li><li>the web application, located on github. To open and show its source code.</li></ul><h2 style='text-align: center; line-height: 2rem; margin-top: 1rem;'>The goal: </h2><p>To push changes of the web application quickly from my local machine to both github and the hosting machine.</p> <h2 style='text-align: center; line-height: 2rem; margin-top: 1rem;'>How to:</h2> <p>Install putty and putty-tools on the local machine:</p> <code> &nbsp;sudo apt install putty putty-tools</code><br><p>Generate private and public SSH keys. Run command to generate the private key on the local machine (press Enter if need to skip password):</p> <code> &nbsp;puttygen -t rsa -C 'some comment' -o keyname.ppk</code><br> <p>Copy the generated key into ~/.ssh/ folder (create this folder if need)</p> <code> &nbsp;cp &nbsp;~/keyname.ppk &nbsp;~/.ssh/keyname.ppk</code><br><p>Extract the public key and save it into *.pub file</p><code> &nbsp;puttygen -L keyname.ppk &gt;&gt; keyname.pub</code><br><p>Run putty and set the hosting machine login:</p><img style='width: calc(100% - 10rem); margin: 1rem 5rem 0.5rem;' class='center' src='articleId_4_imageN_1.png' loading='lazy'><p>Set private key</p><img style='width: calc(100% - 10rem); margin: 1rem 5rem 0.5rem;' class='center' src='articleId_4_imageN_2.png' loading='lazy'><p>Set the settings as in the picture below:</p><img style='width: calc(100% - 10rem); margin: 1rem 5rem 0.5rem;' class='center' src='articleId_4_imageN_3.png' loading='lazy'><img style='width: calc(100% - 10rem); margin: 1rem 5rem 0.5rem;' class='center' src='articleId_4_imageN_4.png' loading='lazy'><p>Terminal window opens. Enter the hosting password in opened terminal.</p><p>Run command in the hosting machine's terminal:</p><code>&nbsp;&nbsp;cat &gt;&gt; ~/.ssh/authorized_keys</code><br><p>Copy and insert the public key from the file ~/.ssh/keyname.pub from the local machine into the hosting machine terminal. Then press 'Enter' and 'CTRL-D'. <strong>So now we can enter on the hosting machine from the local machine without entering password each time</strong></p><h2 style='text-align: center; line-height: 2rem; margin-top: 1rem;'>In order to push changes from local machine to github without password</h2><p>Use ssh instead of http. Remove origin if its http.</p><code>&nbsp;&nbsp;git remote rm origin</code><br><p>Add ssh url</p><code>&nbsp;&nbsp;git remote add origin git@github.com:&lt;username&gt;/&lt;repo&gt;.git</code><br><p>Generate ssh key inside .ssh/ folder. It will ask for path and passphrase where you can just press enter and proceed.</p><code>&nbsp;&nbsp;cd ~/.ssh</code><br><code>&nbsp;&nbsp;ssh-keygen</code><br><p>Copy the key. You can view your key using. If you hadn't specified a different path then this is the default one.</p><code>&nbsp;&nbsp;cat ~/.ssh/id_rsa.pub</code><br><p>Add this key to your github account. Next do</p><code>&nbsp;&nbsp;ssh -T git@github.com</code><br><p>You will get a welcome message in your console. 'cd' into to your project folder. <code>git push -u origin master</code> now works!</p>" 
    }
]